package com.sarxos.medusa.math;

import com.sarxos.medusa.market.Quote;
import com.tictactec.ta.lib.Core;
import com.tictactec.ta.lib.MInteger;


/**
 * Few TA methods.
 * 
 * @author Bartosz Firyn (SarXos)
 */
public class TA {

	/**
	 * Static instance of TA core.
	 */
	private static Core ta = new Core();

	/**
	 * Calculate SAR for N-days period. Use acceleration and max step size given
	 * as the arguments.<br>
	 * <br>
	 * 
	 * Developed by Welles Wilder, the Parabolic SAR refers to a price and time
	 * based trading system. Wilder called this the
	 * "Parabolic Time/Price System". SAR stands for
	 * "<b>S</b>top <b>A</b>nd <b>R</b>everse", which is the actual indicator
	 * used in the system. SAR trails price as the trend extends over time. The
	 * indicator is below prices when prices are rising and above prices when
	 * prices are falling. In this regard, the indicator stops and reverses when
	 * the price trend reverses and breaks above or below the indicator.<br>
	 * <br>
	 * 
	 * Input arguments are:
	 * <ul>
	 * <li>a - acceleration factor (classically 0.02),</li>
	 * <li>ma - maximum incremental acceleration factor value (classically 0.2).
	 * </li>
	 * </ul>
	 * 
	 * Acceleration factor (a) starting at e.g. 0.02, increases by 0.02 each
	 * time the extreme point makes a new high. This factor can reach a maximum
	 * of e.g. 0.20, no matter how long the uptrend extends.<br>
	 * <br>
	 * 
	 * @param q - actual quote to start counting from
	 * @param N - time interval (days)
	 * @param a - acceleration factor (classic dimension is about 0.02)
	 * @param ma - maximum incremental acceleration factor value (SAR is more
	 *            sensible if it is higher, normally about 0.2)
	 * @return
	 */
	public static double[] sar(Quote q, int N, double a, double ma) {

		if (N < 1) {
			throw new IllegalArgumentException("SAR interval must be positive");
		}

		// last element from TA SAR output is always == 0, make input array one
		// element wider
		int P = N + 1;

		double[][] quotes = SX.detach(q, P);

		double[] high = quotes[1];
		double[] low = quotes[2];
		double[] sar = new double[P]; // SAR from TA
		double[] ret = new double[N]; // to return - take original width

		ta.sar(0, P - 1, high, low, a, ma, new MInteger(), new MInteger(), sar);

		System.arraycopy(sar, 0, ret, 0, N);

		return ret;
	}

	/**
	 * Developed J. Welles Wilder, the Relative Strength Index (RSI) is a
	 * momentum oscillator that measures the speed and change of price
	 * movements. RSI oscillates between zero and 100. Traditionally, and
	 * according to Wilder, RSI is considered overbought when above 70 and
	 * oversold when below 30. Signals can also be generated by looking for
	 * divergences, failure swings and centerline crossovers. RSI can also be
	 * used to identify the general trend.
	 * 
	 * @param q - last quote to start counting from
	 * @param N - time interval (days)
	 * @param P - RSI period (normally 14 days)
	 * @return Return double array of RSI values
	 */
	public static double[] rsi(Quote q, int N, int P) {

		if (N < 1) {
			throw new IllegalArgumentException("RSI interval must be positive");
		}
		if (P < 1) {
			throw new IllegalArgumentException("RSI period must be positive");
		}

		// last P output RSI values are always == 0 because of the RSI algorithm
		// specification - need wider input arrays to overcome that issue
		int K = N + P;

		double[] close = SX.detach(q, K)[3];
		double[] rsi = new double[K];
		double[] ret = new double[N];

		ta.rsi(0, K - 1, close, P, new MInteger(), new MInteger(), rsi);

		System.arraycopy(rsi, 0, ret, 0, N);

		return ret;
	}

	// public static void main(String[] args) {
	//
	// List<Quote> quotes = QuotesRegistry.getInstance().getQuotes(Symbol.KGH);
	// Quote q = quotes.get(quotes.size() - 1);
	//
	// int N = 30;
	//
	// Quote[] qus = SX.list(q, N);
	// double[] close = SX.detach(q, N)[3];
	// double[] rsi = rsi(q, N, 14);
	//
	// for (int i = 0; i < N; i++) {
	// System.out.println(qus[i].getDateString() + " " + rsi[i]);
	// }
	//
	// }
}
